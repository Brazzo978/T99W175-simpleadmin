#!/bin/bash
set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
. "$SCRIPT_DIR/session_utils.sh"

SCHEDULE_FILE="/persist/cron/root"

# Ensure cron schedule file exists and is writable.
# On this platform lighttpd runs as www-data, so the file must already have
# permissions that allow updates (prepared by /etc/init.d/crontab).
ensure_schedule_file() {
    local schedule_dir
    schedule_dir="$(dirname "$SCHEDULE_FILE")"

    mkdir -p "$schedule_dir" || return 1

    if [ ! -f "$SCHEDULE_FILE" ]; then
        : > "$SCHEDULE_FILE" || return 1
    fi

    return 0
}

# JSON escape helper
json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    printf '"%s"' "$str"
}

# URL decode helper
url_decode() {
    local data="${1//+/ }"
    printf '%b' "${data//%/\\x}"
}

# Parse query string or POST data
parse_params() {
    local qs="$1"
    schedule=""
    action=""
    
    IFS='&' read -ra pairs <<< "$qs"
    for pair in "${pairs[@]}"; do
        [ -z "$pair" ] && continue
        key="${pair%%=*}"
        val="${pair#*=}"
        val=$(url_decode "$val")
        case "$key" in
            schedule) schedule="$val" ;;
            action) action="$val" ;;
        esac
    done
}

# Authentication check
if ! session_load; then
    send_json_response 401 '{"success":false,"message":"Authentication required"}'
    exit 0
fi

if ! session_require_role "admin"; then
    send_json_response 403 '{"success":false,"message":"Admin privileges required"}'
    exit 0
fi

# Read current schedule from file
read_schedule_file() {
    if [ -f "$SCHEDULE_FILE" ]; then
        schedule=$(grep -v '^\s*$' "$SCHEDULE_FILE" | head -n1)
    else
        schedule=""
    fi
}

# Save schedule to file
save_schedule() {
    local schedule_line="$1"
    ensure_schedule_file || return 1
    printf '%s\n' "$schedule_line" > "$SCHEDULE_FILE"
}

# Validate cron schedule format
validate_schedule() {
    local line="$1"
    
    # Empty string is valid (means no schedule)
    if [ -z "$line" ]; then
        return 0
    fi
    
    local field_count
    field_count=$(echo "$line" | awk '{print NF}')

    if [ "$field_count" -lt 5 ]; then
        send_json_response 400 '{"success":false,"message":"Invalid cron format. Expect at least 5 fields (minute hour day month weekday)."}'
        exit 1
    fi
}

# Handle GET request
handle_get() {
    read_schedule_file
    local schedule_json
    schedule_json=$(json_escape "$schedule")
    
    local payload
    payload=$(cat <<EOF
{
  "success":true,
  "schedule":${schedule_json}
}
EOF
)
    send_json_response 200 "$payload"
}

# Handle POST/DELETE request
handle_post() {
    if [ -n "${CONTENT_LENGTH:-}" ]; then
        read -r -n "$CONTENT_LENGTH" POST_DATA
    else
        read -r POST_DATA
    fi
    
    parse_params "$POST_DATA"

    # If action is delete or schedule is empty, clear the file content.
    # Do not remove the file: we preserve owner/group prepared by init script.
    if [ "$action" = "delete" ] || [ -z "${schedule// }" ]; then
        if ! ensure_schedule_file || ! : > "$SCHEDULE_FILE"; then
            send_json_response 500 '{"success":false,"message":"Unable to clear schedule file. Check /persist/cron/root permissions."}'
            exit 1
        fi
        send_json_response 200 '{"success":true,"schedule":""}'
        exit 0
    fi

    # Validate and save schedule
    validate_schedule "$schedule"
    if ! save_schedule "$schedule"; then
        send_json_response 500 '{"success":false,"message":"Unable to save schedule. Check /persist/cron/root permissions."}'
        exit 1
    fi
    
    local schedule_json
    schedule_json=$(json_escape "$schedule")
    
    local payload
    payload=$(cat <<EOF
{
  "success":true,
  "schedule":${schedule_json}
}
EOF
)
    send_json_response 200 "$payload"
}

# Route based on request method
case "$REQUEST_METHOD" in
    GET)
        handle_get
        ;;
    POST)
        handle_post
        ;;
    DELETE)
        action="delete"
        handle_post
        ;;
    *)
        send_json_response 405 '{"success":false,"message":"Unsupported method"}'
        ;;
esac
