#!/bin/bash
function urldecode() { : "${*//+/ }"; echo -e "${_//%/\\x}"; }

atcmd=""
if [ "${QUERY_STRING}" ]; then
    IFS='&' read -r -a params <<< "${QUERY_STRING}"
    for param in "${params[@]}"; do
        key="${param%%=*}"
        value="${param#*=}"
        if [ "$key" = "atcmd" ]; then
            atcmd="$value"
        fi
    done
fi

x=$(urldecode "$atcmd")

LOCK_FILE="/tmp/atcommand.lock"

output=""
if [ -n "${x}" ]; then
    # Serialize AT command access to prevent microcom lock collisions
    exec 200>"$LOCK_FILE"
    locked=false
    for attempt in $(seq 1 20); do
        if flock -n 200; then
            locked=true
            break
        fi
        sleep 1
    done
    if [ "$locked" != "true" ]; then
        echo "Content-type: text/plain"
        echo "$x"
        echo ""
        echo "ERROR: AT port busy"
        exit 0
    fi
    # Clear stale microcom lock (we serialize access with flock)
    rm -f /var/lock/LCK..ttyOUT2

    IFS=';' read -r -a commands <<< "${x}"
    for cmd in "${commands[@]}"; do
        cmd="$(echo "$cmd" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
        if [ -z "$cmd" ]; then
            continue
        fi

        # Initialize wait time to 200 ms
        wait_time=200
        while true; do
            runcmd=$(echo -en "$cmd\r\n" | microcom -t $wait_time /dev/ttyOUT2)
            # Check if "OK" or "ERROR" is present in the response
            if [[ $runcmd =~ "OK" ]] || [[ $runcmd =~ "ERROR" ]]; then
                break  # Exit the loop if "OK" or "ERROR" is found
            fi
            # If neither "OK" nor "ERROR" is found, increment wait time by 1 second
            ((wait_time++))
        done

        if [ -z "$output" ]; then
            output="$runcmd"
        else
            output="$output"$'\n'"$runcmd"
        fi
    done
fi

echo "Content-type: text/plain"
echo "$x"
echo ""
echo "$output"
