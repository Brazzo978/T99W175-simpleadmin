#!/bin/bash
set -eu

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=/dev/null
. "$SCRIPT_DIR/session_utils.sh"

WATCHDOG_FILE="/opt/scripts/Watchdog"
SERVICE_NAME="connection-watchdog.service"

json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    printf '%s' "$str"
}

load_defaults() {
    WD_ENABLED="0"
    WD_TARGETS="1.1.1.1,8.8.8.8"
    WD_FAIL_COUNT="3"
    WD_CHECK_INTERVAL="10"
    WD_PING_TIMEOUT_MS="5000"
    WD_ACTION="cfun"
    WD_CFUN_DELAY="5"
    WD_BOOT_GRACE="600"
}

load_config() {
    load_defaults
    if [ -f "$WATCHDOG_FILE" ]; then
        # shellcheck disable=SC1090
        . "$WATCHDOG_FILE"
    fi

    # Backward compatibility with WD_PING_TIMEOUT in seconds.
    if [ -z "${WD_PING_TIMEOUT_MS:-}" ] && [ -n "${WD_PING_TIMEOUT:-}" ]; then
        WD_PING_TIMEOUT_MS=$((WD_PING_TIMEOUT * 1000))
    fi
}

save_config() {
    mkdir -p "$(dirname "$WATCHDOG_FILE")"
    cat > "$WATCHDOG_FILE" <<CFG
# Connection watchdog configuration
# Generated by SimpleAdmin GUI
WD_ENABLED="$WD_ENABLED"
WD_TARGETS="$WD_TARGETS"
WD_FAIL_COUNT="$WD_FAIL_COUNT"
WD_CHECK_INTERVAL="$WD_CHECK_INTERVAL"
WD_PING_TIMEOUT_MS="$WD_PING_TIMEOUT_MS"
WD_ACTION="$WD_ACTION"
WD_CFUN_DELAY="$WD_CFUN_DELAY"
WD_BOOT_GRACE="$WD_BOOT_GRACE"
CFG
}

service_control() {
    local enabled="$1"

    if command -v systemctl >/dev/null 2>&1; then
        if [ "$enabled" = "1" ]; then
            systemctl enable "$SERVICE_NAME" >/dev/null 2>&1 || true
            systemctl restart "$SERVICE_NAME" >/dev/null 2>&1 || true
        else
            systemctl disable "$SERVICE_NAME" >/dev/null 2>&1 || true
            systemctl stop "$SERVICE_NAME" >/dev/null 2>&1 || true
        fi
    elif command -v service >/dev/null 2>&1; then
        if [ "$enabled" = "1" ]; then
            service connection-watchdog restart >/dev/null 2>&1 || true
        else
            service connection-watchdog stop >/dev/null 2>&1 || true
        fi
    fi
}

validate_ipv4_csv() {
    local input="$1"
    local IFS=','
    local item octet

    [ -n "$input" ] || return 1

    for item in $input; do
        item="$(echo "$item" | xargs)"
        echo "$item" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$' || return 1
        IFS='.' read -r o1 o2 o3 o4 <<EOI
$item
EOI
        for octet in "$o1" "$o2" "$o3" "$o4"; do
            [ "$octet" -ge 0 ] 2>/dev/null && [ "$octet" -le 255 ] 2>/dev/null || return 1
        done
    done

    return 0
}

if ! session_load; then
    send_json_response 401 '{"success":false,"message":"Authentication required"}'
    exit 0
fi

if [ "$REQUEST_METHOD" = "POST" ] && ! session_require_role "admin"; then
    send_json_response 403 '{"success":false,"message":"Admin privileges required"}'
    exit 0
fi

case "$REQUEST_METHOD" in
    GET)
        load_config

        payload=$(cat <<JSON
{
  "success":true,
  "enabled":$([ "$WD_ENABLED" = "1" ] && echo true || echo false),
  "targets":"$(json_escape "$WD_TARGETS")",
  "failCount":$WD_FAIL_COUNT,
  "checkInterval":$WD_CHECK_INTERVAL,
  "pingTimeoutMs":$WD_PING_TIMEOUT_MS,
  "action":"$(json_escape "$WD_ACTION")",
  "cfunDelay":$WD_CFUN_DELAY,
  "bootGrace":$WD_BOOT_GRACE
}
JSON
)
        send_json_response 200 "$payload"
        ;;
    POST)
        if [ -n "${CONTENT_LENGTH:-}" ]; then
            POST_DATA=$(head -c "$CONTENT_LENGTH")
        else
            POST_DATA=""
        fi

        enabled=$(echo "$POST_DATA" | sed -n 's/.*"enabled":\(true\|false\).*/\1/p')
        targets=$(echo "$POST_DATA" | sed -n 's/.*"targets":"\([^"]*\)".*/\1/p')
        fail_count=$(echo "$POST_DATA" | sed -n 's/.*"failCount":\([0-9]\+\).*/\1/p')
        check_interval=$(echo "$POST_DATA" | sed -n 's/.*"checkInterval":\([0-9]\+\).*/\1/p')
        action=$(echo "$POST_DATA" | sed -n 's/.*"action":"\([^"]*\)".*/\1/p')
        ping_timeout_ms=$(echo "$POST_DATA" | sed -n 's/.*"pingTimeoutMs":\([0-9]\+\).*/\1/p')
        cfun_delay=$(echo "$POST_DATA" | sed -n 's/.*"cfunDelay":\([0-9]\+\).*/\1/p')
        boot_grace=$(echo "$POST_DATA" | sed -n 's/.*"bootGrace":\([0-9]\+\).*/\1/p')

        load_config

        [ "$enabled" = "true" ] || [ "$enabled" = "false" ] || { send_json_response 400 '{"success":false,"message":"Invalid enabled value"}'; exit 0; }
        validate_ipv4_csv "$targets" || { send_json_response 400 '{"success":false,"message":"Invalid targets list"}'; exit 0; }
        [ -n "$fail_count" ] && [ "$fail_count" -ge 1 ] && [ "$fail_count" -le 60 ] || { send_json_response 400 '{"success":false,"message":"Invalid failCount"}'; exit 0; }
        [ -n "$check_interval" ] && [ "$check_interval" -ge 5 ] && [ "$check_interval" -le 3600 ] || { send_json_response 400 '{"success":false,"message":"Invalid checkInterval"}'; exit 0; }
        [ -n "$ping_timeout_ms" ] && [ "$ping_timeout_ms" -ge 100 ] && [ "$ping_timeout_ms" -le 30000 ] || { send_json_response 400 '{"success":false,"message":"Invalid pingTimeoutMs"}'; exit 0; }
        [ "$action" = "cfun" ] || [ "$action" = "reboot" ] || { send_json_response 400 '{"success":false,"message":"Invalid action"}'; exit 0; }
        if [ -n "$cfun_delay" ]; then
            [ "$cfun_delay" -ge 1 ] && [ "$cfun_delay" -le 120 ] || { send_json_response 400 '{"success":false,"message":"Invalid cfunDelay"}'; exit 0; }
            WD_CFUN_DELAY="$cfun_delay"
        fi
        [ -n "$boot_grace" ] && [ "$boot_grace" -ge 0 ] && [ "$boot_grace" -le 3600 ] || { send_json_response 400 '{"success":false,"message":"Invalid bootGrace"}'; exit 0; }

        WD_ENABLED=$([ "$enabled" = "true" ] && echo "1" || echo "0")
        WD_TARGETS="$targets"
        WD_FAIL_COUNT="$fail_count"
        WD_CHECK_INTERVAL="$check_interval"
        WD_ACTION="$action"
        WD_PING_TIMEOUT_MS="$ping_timeout_ms"
        WD_BOOT_GRACE="$boot_grace"

        save_config
        service_control "$WD_ENABLED"

        payload=$(cat <<JSON
{
  "success":true,
  "enabled":$([ "$WD_ENABLED" = "1" ] && echo true || echo false),
  "targets":"$(json_escape "$WD_TARGETS")",
  "failCount":$WD_FAIL_COUNT,
  "checkInterval":$WD_CHECK_INTERVAL,
  "pingTimeoutMs":$WD_PING_TIMEOUT_MS,
  "action":"$(json_escape "$WD_ACTION")",
  "cfunDelay":$WD_CFUN_DELAY,
  "bootGrace":$WD_BOOT_GRACE
}
JSON
)
        send_json_response 200 "$payload"
        ;;
    *)
        send_json_response 405 '{"success":false,"message":"Unsupported method"}'
        ;;
esac
