#!/bin/bash
# Foxconn T99W175 PCIe-RC modem configuration script

# MobileAP Configuration
CONFIG_FILE="/etc/data/mobileap_cfg.xml"

# Function to color values
colorize() {
    CYAN_BOLD="\033[1;36m"
    DARK_GREEN_BOLD="\e[1;32m"
    GREEN_BOLD="\e[1;32m"
    YELLOW_BOLD="\e[1;33m"
    ORANGE_BOLD="\e[1;38;5;208m"
    WHITE_BOLD="\e[1;37m"
    RED_BOLD="\e[1;31m"
    RESET="\e[0m"
    local val="$1"
    local type="$2"
    case "$type" in
        cyan)
            echo -e "${CYAN_BOLD}${val}${RESET}"
            ;;    
        green)
            echo -e "${GREEN_BOLD}${val}${RESET}"
            ;;
        red)
            echo -e "${RED_BOLD}${val}${RESET}"
            ;;
        yellow)
            echo -e "${YELLOW_BOLD}${val}${RESET}"
            ;;
        white)
            echo -e "${WHITE_BOLD}${val}${RESET}"
            ;;
        rsrp)
            if awk "BEGIN{exit !($val >= -85)}"; then
                echo -e "${DARK_GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -95)}"; then
                echo -e "${GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -105)}"; then
                echo -e "${YELLOW_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -115)}"; then
                echo -e "${ORANGE_BOLD}$val${RESET}"
            else
                echo -e "${RED_BOLD}$val${RESET}"
            fi
            ;;
        rsrq)
            if awk "BEGIN{exit !($val >= -6)}"; then
                echo -e "${DARK_GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -10)}"; then
                echo -e "${GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -15)}"; then
                echo -e "${YELLOW_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -20)}"; then
                echo -e "${ORANGE_BOLD}$val${RESET}"
            else
                echo -e "${RED_BOLD}$val${RESET}"
            fi
            ;;
        rssi)
            if awk "BEGIN{exit !($val >= -75)}"; then
                echo -e "${DARK_GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -85)}"; then
                echo -e "${GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -95)}"; then
                echo -e "${YELLOW_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= -105)}"; then
                echo -e "${ORANGE_BOLD}$val${RESET}"
            else
                echo -e "${RED_BOLD}$val${RESET}"
            fi
            ;;
        snr)
            if awk "BEGIN{exit !($val >= 22)}"; then
                echo -e "${DARK_GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= 15)}"; then
                echo -e "${GREEN_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= 10)}"; then
                echo -e "${YELLOW_BOLD}$val${RESET}"
            elif awk "BEGIN{exit !($val >= 3)}"; then
                echo -e "${ORANGE_BOLD}$val${RESET}"
            else
                echo -e "${RED_BOLD}$val${RESET}"
            fi
            ;;
        temp)
            local temp=$(echo "$val" | grep -o -E '[0-9]+')
            if [ "$temp" -le 35 ]; then
                echo -e "${GREEN_BOLD}${temp}°C${RESET}"
            elif [ "$temp" -le 50 ]; then
                echo -e "${YELLOW_BOLD}${temp}°C${RESET}"
            else
                echo -e "${RED_BOLD}${temp}°C${RESET}"
            fi
            ;;
        percent)
            if [ "$val" -lt 30 ]; then
                echo -e "${RED_BOLD}${val}%${RESET}"
            elif [ "$val" -lt 50 ]; then
                echo -e "${YELLOW_BOLD}${val}%${RESET}"
            else
                echo -e "${GREEN_BOLD}${val}%${RESET}"
            fi
            ;;
        *)
            echo -e "$val"
            ;;
    esac
}

# ANSI Escape
RESTORE_CURSOR="\033[u"
HIDE_CURSOR="\033[?25l"
SHOW_CURSOR="\033[?25h"

# Function to send AT commands and parse response
at_command() {
    local command="$1"
    local success_msg="$2"
    local error_msg="$3"
    local extra_ok="$4"

    out=$(atcli_smd8 "$command" 2>&1 | grep -v '^AT')

    if echo "$out" | grep -q "ERROR"; then
        echo -e "$(colorize "${error_msg:-'AT command returned ERROR!'}" red)"
        [ -n "$out" ] && echo "$out"
        return 1
    elif echo "$out" | grep -q "OK"; then
        echo -e "$(colorize "${success_msg:-'AT command successful!'}" green)"
        return 0
    elif [ -n "$extra_ok" ] && echo "$out" | grep -q "$extra_ok"; then
        echo -e "$(colorize "${success_msg:-'AT command successful!'}" green)"
        return 0
    else
        echo -e "$(colorize "Unexpected response:" yellow) $out"
        return 2
    fi
}

# Function for Temperature, Device Mode, Registration Status, Signal and CA Status
update_dynamic_info() {
    local hide_sensitive=${1:-0}
    local output=""

    output="========================================\n"
    output+="            $(colorize "MODEM STATUS" white)               \n"
    output+="========================================\n"

    # System uptime
    local uptime_info=$(awk '{d=int($1/86400); h=int(($1%86400)/3600); m=int(($1%3600)/60); printf "%d days, %d hours, %d minutes\n", d, h, m}' /proc/uptime)
    output+=" \n"
    output+="System Uptime: $(colorize "$uptime_info" white)\n"
    output+=" \n"

    # Get ATI info
    local ati_output=$(atcli "ATI" 2>/dev/null)
    local temp_output=$(atcli "AT^TEMP?" 2>/dev/null)
    local hw_version=$(atcli "AT+SKUID" 2>/dev/null)
    local sw_version=$(atcli "AT^VERSION?" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local manufacturer=$(echo "$ati_output" | grep "Manufacturer:" | cut -d':' -f2 | xargs)
        local model=$(echo "$ati_output" | grep "Model:" | cut -d':' -f2 | xargs)
        local imei=$(echo "$ati_output" | grep "IMEI:" | cut -d':' -f2 | xargs)
        local hw_ver=$(echo "$hw_version" | grep "HW Revision:" | cut -d':' -f2 | awk '{print $1}' | xargs)
        local sw_ver=$(echo "$sw_version" | grep "VERSION:" | cut -d':' -f2 | awk '{print $1}' | xargs)
        local pa_temp=$(echo "$temp_output" | grep "PA:" | cut -d':' -f2 | xargs)
        local skin_temp=$(echo "$temp_output" | grep "Skin Sensor:" | cut -d':' -f2 | xargs)
        local tsens_temp=$(echo "$temp_output" | grep "TSENS:" | cut -d':' -f2 | xargs)

        output+="Modem Info:\n"
        output+="  Manufacturer: $(colorize "$manufacturer" white)\n"
        output+="  Model: $(colorize "$model" white)\n"
        if [ "$hide_sensitive" -eq 0 ]; then
            output+="  IMEI: $(colorize "$imei" white)\n"
        fi
        output+="  HW Version: $(colorize "$hw_ver" white)\n"
        output+="  SW Version: $(colorize "$sw_ver" white)\n"
    fi

    # Get temperature info
    local temp_output=$(atcli "AT^TEMP?" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local pa_temp=$(echo "$temp_output" | grep "PA:" | cut -d':' -f2 | xargs)
        local skin_temp=$(echo "$temp_output" | grep "Skin Sensor:" | cut -d':' -f2 | xargs)
        local tsens_temp=$(echo "$temp_output" | grep "TSENS:" | cut -d':' -f2 | xargs)
        
        output+="  PA Temp: $(colorize $pa_temp temp)\n"
        output+="  SKIN Temp: $(colorize $skin_temp temp)\n"
        output+="  TSENS Temp: $(colorize $tsens_temp temp)\n"
        output+=" \n"
    fi
    
    # Get device mode
    radio_current_mode=$(atcli "AT^SLMODE?" | grep '\^SLMODE:' | cut -d "," -f 2 | tr -d '\r')
    case "$radio_current_mode" in
        1) radio_mode="3G only" ;;
        2) radio_mode="4G only" ;;
        3) radio_mode="3G+4G" ;;
        4) radio_mode="5G only" ;;
        5) radio_mode="3G+5G" ;;
        6) radio_mode="4G+5G" ;;
        7) radio_mode="3G+4G+5G" ;;
        *) radio_mode="Unknown" ;;
    esac
    
    output+="Device Mode: $(colorize "$radio_mode" green)\n"

    # Get current SIM slot status & IMSI
    local slot_response=$(atcli AT^SWITCH_SLOT? | tr -d '\r')
    local current_sim_slot

    if echo "$slot_response" | grep -q "SIM1 ENABLE"; then
        current_sim_slot="SIM SLOT 1"        
    elif echo "$slot_response" | grep -q "SIM2 ENABLE"; then
        current_sim_slot="SIM SLOT 2"
    elif echo "$slot_response" | grep -q "ERROR"; then
        current_sim_slot="$(colorize "ERROR" red) - Unable to read SIM slot status"
    else
        current_sim_slot="Unknown"
    fi

    # Get current IMSI
    local current_imsi=$(atcli AT+CIMI | grep -v AT+CIMI | grep -v OK | tr -d '\r\n')
    
    output+=" \n"
    output+="SIM Status:\n"
    output+="  Active SIM Slot: $(colorize "$current_sim_slot" white)\n"
    
    # Print IMSI only if it's not ERROR
    if ! echo "$current_imsi" | grep -q "ERROR"; then
        if [ "$hide_sensitive" -eq 0 ]; then
            output+="  Active SIM IMSI: $(colorize "$current_imsi" white)\n"
        fi
    fi

    # Get registration status
    local creg_output=$(atcli "AT+CREG?" 2>/dev/null)
    local reg_status=""
    local show_network_info=false
    
    if [ $? -eq 0 ]; then
        local creg_code=$(echo "$creg_output" | grep "+CREG:" | awk -F',' '{print $2}' | tr -d ' \r\n')
        case $creg_code in
            1)
                reg_status="$(colorize "Yes" green) ($(colorize "Home" white))"
                show_network_info=true
                ;;
            3)
                reg_status="$(colorize "No" red) ($(colorize "Denied" red))"
                ;;
            5)
                reg_status="$(colorize "Yes" green) ($(colorize "Roaming" yellow))"
                show_network_info=true
                ;;
            *)
                reg_status="$(colorize "Unknown" white)"
                ;;
        esac
        output+=" \n"
        output+="Network Status:\n"
        output+="  Registered: $reg_status\n"
    fi
    
    # Show operator and signal only if registered (status 1 or 5)
    if [ "$show_network_info" = true ]; then
        # Get operator name
        local cops_output=$(atcli "AT+COPS?" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local operator=$(echo "$cops_output" | awk -F'"' '
                /\+COPS:/ {
                first_word = $2
                sub(/\r/,"",first_word)
                sub(/^[ \t]+/,"",first_word)
                sub(/[ \t].*$/,"",first_word)
                if (first_word != "" && !seen[first_word]++) print first_word
                }')
            if [ -n "$operator" ]; then
                output+="  Operator: $(colorize "$operator" white)\n"
            fi
        fi
        
        # Get signal strength
        local csq_output=$(atcli "AT+CSQ" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local csq=$(echo "$csq_output" | grep -o "+CSQ: [0-9]\{1,2\}" | grep -o "[0-9]\{1,2\}")
            if [ -n "$csq" ] && [ "$csq" -ne 99 ]; then
                local csq_per=$(( csq * 100 / 31 ))
                local csq_rssi=$(( 2 * csq - 113 ))
                output+="  Signal: $(colorize $csq_per percent) ($(colorize $csq_rssi rssi) dBm)\n"
                output+="  CA Status:\n"
                output+="  ---------------------------------------------------------------------------------------------------------\n"
                output+="$(parse_debug)\n"
            else
                output+="  Signal: No signal\n"
            fi
        fi
        
        output+="\n"
        output+="$(show_pdp_contexts)"
    fi
    
    output+=" \n"
    output+="Press $(colorize "CTRL+C" yellow) to quit\n"
 
    echo -ne "$RESTORE_CURSOR"
    PATEMP_ROW=$(echo -e "$output" | grep -n "========================================" | head -n 1 | cut -d: -f1)
    echo -ne "\033[${PATEMP_ROW};0H"
    echo -ne "\033[J"
    printf "%b" "$output"

}

# Functions to validate MAC address, IP and Subnet
validate_netval() {
    local value="$1"
    local type="$2"

    case "$type" in
        mac)
            [[ $value =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] && return 0 || return 1
            ;;
        ip)
            if [[ $value =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
                IFS='.' read -r -a octets <<< "$value"
                for octet in "${octets[@]}"; do
                    if ! [[ $octet =~ ^[0-9]+$ ]]; then
                        return 1
                    fi
                    if ((octet < 0 || octet > 255)); then
                        return 1
                    fi
                done
                return 0
            else
                return 1
            fi
            ;;
        netmask)
            [[ $value =~ ^(255|254|252|248|240|224|192|128|0+)\.(255|254|252|248|240|224|192|128|0+)\.(255|254|252|248|240|224|192|128|0+)\.(255|254|252|248|240|224|192|128|0+)$ ]] && return 0 || return 1
            ;;
        *)
            return 1
            ;;
    esac
}

# Function to read XML value
get_xml_value() {
    local key=$1
    local file=$2
    grep "<$key>" "$file" | sed "s/.*<$key>\(.*\)<\/$key>.*/\1/" | tr -d ' '
}

# Function to modify XML value
set_xml_value() {
    local key=$1
    local value=$2
    local file=$3
    local tmpfile="/tmp/mobileap_cfg_tmp.xml"

    # Create modified version in /tmp
    sed "s|<$key>.*</$key>|<$key>$value</$key>|" "$file" > "$tmpfile"

    # Copy back to original location
    cp "$tmpfile" "$file"

    # Clean up
    rm -f "$tmpfile"
}

# Function to show current configuration
show_mobileap_config() {
    echo " "
    echo -e "======= $(colorize "CURRENT CONFIGURATION" white) ======="
    echo " "

    # Read current values
    local autoconnect=$(get_xml_value "AutoConnect" "$CONFIG_FILE")
    local roaming=$(get_xml_value "Roaming" "$CONFIG_FILE")
    local bridge=$(get_xml_value "IPPassthroughEnable" "$CONFIG_FILE")
    local bridge_mac=$(get_xml_value "IPPassthroughHostMAC" "$CONFIG_FILE")
    local ip=$(get_xml_value "APIPAddr" "$CONFIG_FILE")
    local mask=$(get_xml_value "SubNetMask" "$CONFIG_FILE")
    local dhcp_enable=$(get_xml_value "EnableDHCPServer" "$CONFIG_FILE")
    local dhcp_start=$(get_xml_value "StartIP" "$CONFIG_FILE")
    local dhcp_end=$(get_xml_value "EndIP" "$CONFIG_FILE")
    local dhcp_lease=$(get_xml_value "LeaseTime" "$CONFIG_FILE")

    # Display configuration
    echo "AutoConnect:        $([ "$autoconnect" = "1" ] && echo -e $(colorize "ENABLED" green) || echo -e $(colorize "DISABLED" red))"
    echo "Roaming:            $([ "$roaming" = "1" ] && echo -e $(colorize "ENABLED" green) || echo -e $(colorize "DISABLED" red))"
    echo " "
    if [ "$bridge" = "1" ]; then
        echo -e "Bridge Mode:        $(colorize "ENABLED" green)"
        if [ -n "$bridge_mac" ]; then
            echo "  MAC Address:      $bridge_mac"
        else
            echo "  MAC Address:      Not configured"
        fi
    else
        echo -e "Bridge Mode:        "$(colorize "DISABLED" red)""
    fi
    echo " "
    echo "Network Configuration:"
    echo -e "  IP Address:       $(colorize "$ip" white)"
    echo -e "  Subnet Mask:      $(colorize "$mask" white)"
    echo -e "  DHCP Server:      $([ "$dhcp_enable" = "1" ] && echo -e $(colorize "ENABLED" green) || echo -e $(colorize "DISABLED" red))"
    if [ "$dhcp_enable" = "1" ]; then
        echo -e "  DHCP Start IP:    $(colorize "$dhcp_start" white)"
        echo -e "  DHCP End IP:      $(colorize "$dhcp_end" white)"
        echo -e "  Lease Time:       $(colorize "$dhcp_lease" white) seconds"
    fi
    echo " "

    # Try to get APN info
    echo "APN Configuration:"
    local apn_info=$(atcli_smd8 "AT+CGDCONT?" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local apn_line=$(echo "$apn_info" | grep "+CGDCONT:")
        if [ -n "$apn_line" ]; then
            local apn_type=$(echo "$apn_line" | awk -F'"' '{print $2}')
            local apn_name=$(echo "$apn_line" | awk -F'"' '{print $4}')

            if [ -n "$apn_name" ]; then
                echo -e "  APN Name:          $(colorize "$apn_name" white)"
                echo -e "  APN Type:          $(colorize "$apn_type" white)"
            else
                echo "  Not configured"
            fi
        else
            echo "  Unable to parse APN information"
        fi
    else
        echo "  Unable to read APN (atcli command not available or failed)"
    fi
}

# Function to set APN
apn_menu() {
    while true; do
        echo " "
        echo -e "======= $(colorize "APN MENU" white) ======="
        echo -e "Enter APN name or $(colorize "Q" yellow) to quit: " 
        read apn_name
        [[ "$apn_name" =~ ^[Qq]$ ]] && return 0
        echo "Select type:"
        echo "1) IPV4"
        echo "2) IPV4V6"
        echo "3) IPV6"
        echo "B) Back to main menu"
        read -p "Choice: " type_choice

        case $type_choice in
            1) apn_type="IP" ;;
            2) apn_type="IPV4V6" ;;
            3) apn_type="IPV6" ;;
            B|b) break ;;
            *) echo "Invalid choice"; return ;;
        esac

        at_command "AT+CGDCONT=1,\"$apn_type\",\"$apn_name\"" \
                "APN Set Successful!" \
                "APN command returned ERROR!"
        if [ $? -ne 0 ]; then
            return 1
        fi

        echo " "
        echo -e "$(colorize "WARNING" yellow)"": To apply APN change you need to powercycle baseband"
        read -p "Do you want to to powercycle the baseband? (y/n): " choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            at_command "AT+CFUN=0" "Radio OFF" "Error turning radio OFF"
            at_command "AT+CFUN=1" "Radio ON, baseband restarted!" "Error turning radio ON"
            if [ $? -eq 0 ]; then
                echo " "
                echo "Baseband powercycle succeeded!"
                return 0
            else
                echo " "
                echo "Error on powercycle baseband!"
                return 1
            fi
        fi
    done
}

# Function to toggle Airplane mode
toggle_airplane_mode() {
    echo " "
    echo -e "======= $(colorize "AIRPLANE MODE" white) ======="
    # Verifica stato attuale
    current=$(atcli_smd8 "AT+CFUN?")
    status=$(echo "$current" | grep -oE '\+CFUN: [01]' | awk '{print $2}' | xargs)
    
    if [ "$status" = "0" ]; then
        echo -e "Airplane mode is currently $(colorize "ENABLED" green)"
        echo -ne "Do you want to $(colorize "DISABLE" red) airplane mode? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            at_command "AT+CFUN=1" \
                       "Airplane mode $(colorize "DISABLED" red)" \
                       "Error settings Airplane mode!"
            return $?
        fi
    elif [ "$status" = "1" ]; then
        echo -e "Airplane mode is currently $(colorize "DISABLED" red)"
        echo -ne "Do you want to $(colorize "ENABLE" green) airplane mode? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            at_command "AT+CFUN=0" \
                       "Airplane mode $(colorize "ENABLED" green)" \
                       "Error settings Airplane mode!"
            return $?
        fi
    else
        echo "Unable to determine airplane mode status."
        return 2
    fi
}

# Function to toggle Autoconnect
toggle_autoconnect() {
    echo -e "======= $(colorize "AUTOCONNECT" white) ======="
    local current=$(get_xml_value "AutoConnect" "$CONFIG_FILE")

    if [ "$current" = "1" ]; then
        echo -e "Autoconnect is currently "$(colorize "ENABLED" green)""
        echo -ne "Do you want to "$(colorize "DISABLE" red)" autoconnect? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            set_xml_value "AutoConnect" "0" "$CONFIG_FILE"
            echo -e "Autoconnect "$(colorize "DISABLED" red)""
            echo " "
            echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
        fi
    else
        echo -e "Autoconnect is currently "$(colorize "DISABLED" red)""
        echo -ne "Do you want to "$(colorize "ENABLE" green)" autoconnect? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            set_xml_value "AutoConnect" "1" "$CONFIG_FILE"
            echo -e "Autoconnect "$(colorize "ENABLED" green)""
            echo " "
            echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
        fi
    fi
}

# Function to toggle Roaming
toggle_roaming() {
    echo -e "======= ${WHITE_BOND}ROAMING${RESET} ======="
    local current=$(get_xml_value "Roaming" "$CONFIG_FILE")

    if [ "$current" = "1" ]; then
        echo -e "Roaming is currently "$(colorize "ENABLED" green)""
        echo -ne "Do you want to "$(colorize "DISABLE" red)" roaming? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            set_xml_value "Roaming" "0" "$CONFIG_FILE"
            echo -e "Roaming "$(colorize "DISABLED" red)""
            echo " "
            echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
        fi
    else
        echo -e "Roaming is currently  "$(colorize "DISABLED" red)""
        echo -ne "Do you want to "$(colorize "ENABLE" green)" roaming? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            set_xml_value "Roaming" "1" "$CONFIG_FILE"
            echo -e "Roaming "$(colorize "ENABLED" green)""
            echo " "
            echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
        fi
    fi
}

# Function to toggle Bridge Mode
toggle_bridge() {
    echo -e "======= ${WHITE_BOND}BRIDGE MODE${RESET} ======="
    local current=$(get_xml_value "IPPassthroughEnable" "$CONFIG_FILE")

    if [ "$current" = "1" ]; then
        echo -e "Bridge Mode is currently "$(colorize "ENABLED" green)""
        echo -ne "Do you want to "$(colorize "DISABLE" red)" Bridge Mode? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            set_xml_value "IPPassthroughEnable" "0" "$CONFIG_FILE"
            set_xml_value "IPPassthroughHostMAC" "0" "$CONFIG_FILE"
            echo -e "Bridge Mode "$(colorize "DISABLED" red)""
            echo " "
            echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
        fi
    else
        echo -e "Bridge Mode is currently "$(colorize "DISABLE" red)""
        echo -ne "Do you want to "$(colorize "ENABLE" green)" Bridge Mode? (y/n): " 
        read choice
        if [[ "$choice" =~ ^[Yy]$ ]]; then
            while true; do
                echo -ne "Enter MAC address (format: AA:BB:CC:DD:EE:FF) or $(colorize "Q" yellow) to quit: "
                read mac_addr
                [[ "$mac_addr" =~ ^[Qq]$ ]] && return 0
                if validate_netval "$mac_addr" mac; then
                    set_xml_value "IPPassthroughEnable" "1" "$CONFIG_FILE"
                    set_xml_value "IPPassthroughMacAddr" "$mac_addr" "$CONFIG_FILE"
                    echo -e "Bridge Mode "$(colorize "ENABLED" green)" with MAC: $(colorize "$mac_addr" white)"
                    echo " "
                    echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
                    break
                else
                    echo -e "Invalid MAC address! Correct format: $(colorize "AA:BB:CC:DD:EE:FF" white)"
                fi
            done
        fi
    fi
}

# Function to change IP
change_ip() {
    echo " "
    echo -ne "======= ${WHITE_BOND}CHANGE IP ADDRESS${RESET} ======="

    # Read current configuration
    local current_ip=$(get_xml_value "APIPAddr" "$CONFIG_FILE")
    local current_mask=$(get_xml_value "SubNetMask" "$CONFIG_FILE")

    echo "Current configuration:"
    echo -e "  IP Address: $(colorize "$current_ip" white)"
    echo -e "  Subnet Mask: $(colorize "$current_mask" white)"
    echo " "

    while true; do
        echo -ne "Enter new board IP (e.g. 192.168.1.1), or $(colorize "Q" yellow) to quit: "
        read new_ip
        [[ "$new_ip" == q ]] && return 0

        if validate_netval "$new_ip" ip; then
            break
        else
            echo "Invalid IP, please enter a correct one"
        fi
    done

    while true; do
        read -p "Enter new subnet mask (e.g. 255.255.255.0): " new_mask
        if validate_netval "$new_mask" netmask; then
            break
        else
            echo "Invalid Netmask, please enter a correct one"
        fi
    done

    # Extract first 3 octets for DHCP range
    local network=$(echo "$new_ip" | cut -d'.' -f1-3)
    local start_ip="${network}.20"
    local end_ip="${network}.60"

    echo " "
    echo "The following changes will be applied:"
    echo -e "  Board IP: $(colorize "$new_ip" white)"
    echo -e "  Subnet Mask: $(colorize "$new_mask" white)"
    echo -e "  DHCP Range: $(colorize "$start_ip - $end_ip" white)"
    echo " "

    read -p "Confirm? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        set_xml_value "APIPAddr" "$new_ip" "$CONFIG_FILE"
        set_xml_value "SubNetMask" "$new_mask" "$CONFIG_FILE"
        set_xml_value "StartIP" "$start_ip" "$CONFIG_FILE"
        set_xml_value "EndIP" "$end_ip" "$CONFIG_FILE"
        echo -e "$(colorize "IP configuration updated successfully!" green)"
        echo " "
        echo -e "$(colorize "WARNING" yellow)"": Reboot the module to apply changes"
    else
        echo "Operation cancelled"
    fi
}

# Function to set device mode
device_mode_menu() {
    while true; do
        echo " "
        echo -e "======= $(colorize "DEVICE MODE MENU" white) ======="
        local radio_current_mode=$(atcli_smd8 AT^SLMODE? | grep '\^SLMODE:' | cut -d "," -f 2 | tr -d '\r')

        case "$radio_current_mode" in
            1) radio_current_mode="3G only" ;;
            2) radio_current_mode="4G only" ;;
            3) radio_current_mode="3G+4G" ;;
            4) radio_current_mode="5G only" ;;
            5) radio_current_mode="3G+5G" ;;
            6) radio_current_mode="4G+5G" ;;
            7) radio_current_mode="3G+4G+5G" ;;
            *) radio_current_mode="Unknown" ;;
        esac

        echo -e "Current Device Mode: $(colorize "$radio_current_mode" green)\n"

        echo "Available modes:"
        echo "1) 3G only"
        echo "2) 4G only"
        echo "3) 3G+4G"
        echo "4) 5G only"
        echo "5) 3G+5G"
        echo "6) 4G+5G"
        echo "7) 3G+4G+5G"
        echo "B) Back to main menu"

        read -p "Enter the number of the desired mode: " choice

        if [[ "$choice" =~ ^[Bb]$ ]]; then
            break
        fi
        if [[ ! "$choice" =~ ^[1-7]$ ]]; then
            echo "Invalid choice."
            return
        fi

        case "$choice" in
            1) choice_str="3G only" ;;
            2) choice_str="4G only" ;;
            3) choice_str="3G+4G" ;;
            4) choice_str="5G only" ;;
            5) choice_str="3G+5G" ;;
            6) choice_str="4G+5G" ;;
            7) choice_str="3G+4G+5G" ;;
        esac

        at_command "AT^SLMODE=1,$choice" \
            "Device Mode successfully set to: $(colorize "${choice_str}" green)\n$(colorize "WARNING" yellow): Reboot the module to apply changes" \
            "$(colorize "ERROR" red): Failed to set Device Mode."
    done
}

# Function to set band lock
band_lock_menu() {
    while true; do 
        show_enabled_disabled_bands() {
            echo " "
            atcli_smd8 "AT^BAND_PREF_EXT?" | grep -E "Enable|Disable" | while IFS= read -r line; 
            do
                if [[ $line =~ WCDMA,Enable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
                    echo -e "WCDMA Enabled Bands: $(colorize "$bands" green)"
                elif [[ $line =~ WCDMA,Disable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
                    [[ -n "$bands" ]] && echo -e "WCDMA Disabled Bands: $(colorize "$bands" red)"
                elif [[ $line =~ LTE,Enable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
                    echo -e "LTE Enabled Bands: $(colorize "$bands" green)"
                elif [[ $line =~ LTE,Disable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
                    [[ -n "$bands" ]] && echo -e "LTE Disabled Bands: $(colorize "$bands" red)"
                elif [[ $line =~ NR5G_NSA,Enable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
                    echo -e "5G NSA Enabled Bands: $(colorize "$bands" green)"
                elif [[ $line =~ NR5G_NSA,Disable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
                    [[ -n "$bands" ]] && echo -e "5G NSA Disabled Bands: $(colorize "$bands" red)"
                elif [[ $line =~ NR5G_SA,Enable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
                    echo -e "5G SA Enabled Bands: $(colorize "$bands" green)"
                elif [[ $line =~ NR5G_SA,Disable ]]; then
                    bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
                    [[ -n "$bands" ]] && echo -e "5G SA Disabled Bands: $(colorize "$bands" red)"
                fi
            done
        }

        reset_band_lock() {
            echo " "
            at_command "AT^BAND_PREF_EXT" \
                "Band Lock revert to stock value" \
                "$(colorize "ERROR" red): Failed to reset Band Lock."
            return $?
        }

        echo " "
        echo -e "======= $(colorize "Band Lock" white) ======="
        echo ""
        echo "1) WCDMA"
        echo "2) LTE"
        echo "3) NR5G_SA"
        echo "4) NR5G_NSA"
        echo "5) Remove Band Lock"
        echo "6) Show Current Configured LTE/NR5G Bands"
        echo "B) Back to main menu"
        echo ""
        read -p "Select an option: " tech_choice

        case $tech_choice in
            1) tech="WCDMA" ;;
            2) tech="LTE" ;;
            3) tech="NR5G_SA" ;;
            4) tech="NR5G_NSA" ;;
            5) reset_band_lock 
               continue ;;
            6) show_enabled_disabled_bands 
               continue ;;
            B|b) break ;;
            *)
                echo -e "$(colorize "ERROR" red): Wrong choice"
                continue ;;
        esac

        echo " "
        read -p "Insert single band, or multiple band with comma (e.g.: 7 or 7,20,28): " bands

        if [[ ! "$bands" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
            echo -e "$(colorize "ERROR" red): Invalid format, please use comma to separate bands"
            return 1
        fi

        local bandlist=$(echo "$bands" | tr ',' ':')

        echo " "
        echo -e "Setting lock for: $(colorize "$tech" white) - Bands: $(colorize "$bands" white)"
        read -p "Are you sure? (y/n): " confirm

        if [[ "$confirm" =~ ^[Yy]$ ]]; then
            at_command "AT^BAND_PREF_EXT=$tech,2,$bandlist" \
                "Band Lock Succeeded!" \
                "$(colorize "ERROR" red): Failed to set Band Lock."
        else
            echo "Operation Aborted"
        fi

    done
}

# Function to set LTE/5G cell lock
cell_lock_menu() {
    while true; do
        echo " "
        echo -e "=======  $(colorize "CELL LOCK MENU (LTE)" white) ======="
        echo ""
        echo "1) Show lock status"
        echo "2) Set lock (PCI/EARFCN) - LTE"
        echo "3) Set lock (SCS/PCI/ARFCN) - 5G"
        echo "4) Remove lock - LTE"
        echo "5) Remove lock - 5G"
        echo "B) Back to main menu"
        read -p "Choose option: " choice

        case "$choice" in
            1)
                output_lte=$(atcli_smd8 'AT^LTE_LOCK?')
                output_5g=$(atcli_smd8 'AT^NR5G_LOCK?')
                if [[ "$output_lte" =~ "Have not set cell lock before" ]]; then
                    echo " "
                    echo "No lock active (LTE)" 
                else
                    pairs_lte=${output_lte#*:}
                    pairs_lte=${pairs_lte%,}
                    pairs_lte=$(echo "$pairs_lte" | sed 's/),(/)\n(/g')
                    echo " "
                    echo "$pairs_lte" | while read -r line; do
                        pairs_lte=${line//[\(\)]/}
                        pairs_lte=${pairs_lte%,}
                        IFS=',' read -r pci earfcn <<< "$pairs_lte"
                        if [[ -n "$pci" && -n "$earfcn" ]]; then
                            echo -ne "Lock to PCI $(colorize "$pci" white) - EARFCN $(colorize "$earfcn" white)\r\n"
                        fi
                    done                      
                fi

                if [[ "$output_5g" =~ "Have not set cell lock before" ]]; then
                    echo " "
                    echo "No lock active (5G)"
                else
                    pairs_5g=${output_5g#*:}
                    pairs_5g=${pairs_5g%,}
                    pairs_5g=$(echo "$pairs_5g" | sed 's/),(/)\n(/g')
                    echo " "
                    echo "$pairs_5g" | while read -r line; do
                        line=$(echo "$line" | tr -d '\r' | xargs)
                        pairs_5g=${line//[\(\)]/}
                        pairs_5g=${pairs_5g%,}
                        IFS=',' read -r band scs_id nr_arfcn pci <<< "$pairs_5g"
                        case $scs_id in
                            0) scs_type="15kHz" ;;
                            1) scs_type="30kHz" ;;
                            2) scs_type="60kHz" ;;
                            *) scs_type="120kHz" ;;
                        esac
                        if [[ -n "$pci" && -n "$scs_type" && -n "$nr_arfcn" && -n "$band" ]]; then
                            echo -ne "Lock to Band $(colorize "$band" white) - SCS $(colorize "$scs_type" white) - PCI $(colorize "$pci" white) - NR-ARFCN $(colorize "$nr_arfcn" white)\r\n"
                        fi
                    done                      
                fi
                ;;

            2)
                echo "Enter PCI (0-503) and EARFCN pairs, separated by space. Max 8 pairs."
                echo "Example: 405 40936 410 41112"
                echo " "                
                read -p "PCI/EARFCN: " entries
                nums=($entries)
                numCount=${#nums[@]}
                if (( numCount < 2 || numCount > 16 || numCount % 2 != 0 )); then
                    echo -e "$(colorize "ERROR" red): enter between 1 and 8 PCI/EARFCN pairs"
                    continue
                fi

                valid=1
                for ((i=0; i<numCount; i+=2)); do
                    pci=${nums[$i]}
                    if (( pci < 0 || pci > 503 )); then
                        echo " "
                        echo -e "$(colorize "ERROR" red) - PCI out of range: $(colorize "$pci" white)"
                        valid=0
                    fi
                done
                if (( valid == 0 )); then
                    continue
                fi

                cmd="AT^LTE_LOCK="
                for ((i=0; i<${#nums[@]}; i+=2)); do
                    cmd+="${nums[$i]},${nums[$i+1]}"
                    if (( i+2 < ${#nums[@]} )); then
                        cmd+=","
                    fi
                done
                echo -e "$(colorize "WARNING" yellow): Reboot the module to apply changes"
                at_command "$cmd" \
                    "Cell Lock Succeeded!" \
                    "Error settings cell lock!"
                at_command "AT^SLMODE=1,7" "Set Radio to Auto-Mode" "Error Set Radio to Auto-Mode"
                ;;

            3)
                echo "Enter NR BAND (1-100), SCS Type (0-3), NR-ARFCN and PCI (0-1007) groups, separated by space."
                echo "Example: 78 1 627264 148"
                echo "SCS Type: 0=15kHz, 1=30kHz, 2=60kHz, 3=120kHz"
                echo " "
                read -p "NRBAND/SCS/NRARFCN/PCI: " entries
                nums=($entries)
                numCount=${#nums[@]}
                if (( numCount != 4 )); then
                    echo -e "$(colorize "ERROR" red): you must enter exactly 4 values: NRBAND SCS NRARFCN PCI"
                    continue
                fi

                valid=1
                for ((i=0; i<numCount; i+=4)); do
                    band=${nums[$i]}
                    scs=${nums[$i+1]}
                    arfcn=${nums[$i+2]}
                    pci=${nums[$i+3]}
                    if (( band < 1 || band > 100 )); then
                        echo " "
                        echo -e "$(colorize "ERROR" red) - NRBAND out of range: $(colorize "$band" white)"
                        valid=0
                    fi
                    if (( scs < 0 || scs > 3 )); then
                        echo " "
                        echo -e "$(colorize "ERROR" red) - SCS out of range: $(colorize "$scs" white)"
                        valid=0
                    fi
                    if (( pci < 0 || pci > 1007 )); then
                        echo " "
                        echo -e "$(colorize "ERROR" red) - PCI out of range: $(colorize "$pci" white)"
                        valid=0
                    fi
                done
                if (( valid == 0 )); then
                    continue
                fi

                cmd="AT^NR5G_LOCK="
                for ((i=0; i<numCount; i+=4)); do
                    cmd+="${nums[$i]},${nums[$i+1]},${nums[$i+2]},${nums[$i+3]}"
                    if (( i+4 < numCount )); then
                        cmd+=","
                    fi
                done
                echo -e "$(colorize "WARNING" yellow): Reboot the module to apply changes"
                at_command "$cmd" \
                    "Cell Lock Succeeded!" \
                    "Error setting cell lock!"
                at_command "AT^SLMODE=1,7" "" ""
                ;;
            4)
                echo " "
                echo -e "LTE lock $(colorize "DISABLED" red)"
                echo -e "$(colorize "WARNING" yellow): Reboot the module to apply changes"
                at_command 'AT^LTE_LOCK' "Lock removed!" "Failed to remove LTE lock!"
                ;;
            5)
                echo " "
                echo -e "NR5G lock $(colorize "DISABLED" red)"
                echo -e "$(colorize "WARNING" yellow): Reboot the module to apply changes"
                at_command 'AT^NR5G_LOCK' "Lock removed!" "Failed to remove 5G lock!"
                ;;                
            B|b) break ;;
            *)
                echo -ne "Invalid choice.\r\n"
                continue
                ;;
        esac
    done
}

# Function to send custom AT commands
at_menu() {
    atcli_smd8 "AT" > /dev/null
    echo " "
    echo "========================================"
    echo -e "     $(colorize "CUSTOM AT COMMAND MODE" white)"
    echo "========================================"
    echo "Type your AT command (without quotes)"
    echo -e "Enter $(colorize "Q" yellow) to quit"
    echo "----------------------------------------"
    
    while true; do
        read -p "$(echo -e "$(colorize "AT>" cyan) ")" atcmd
        case $atcmd in
            Q|q)
                echo "Exiting Custom AT Command mode..."
                break
                ;;
            "")
                echo "No command entered!"
                ;;
            '?')
                echo -ne "Enter AT command to send, or enter $(colorize "Q" yellow) to quit\r\n"
                ;;
            *)
                if [[ ! "$atcmd" =~ ^[Aa][Tt] ]]; then
                    echo -ne "$(colorize "ERROR" red): Command must start with 'AT'\r\n"
                    continue
                fi
                atcmd="${atcmd//[$'\r\n']}" 
                atcli_smd8 "$atcmd"
                ;;
        esac
    done
}

# Function to change SIM slot
simslot_menu() {
    while true; do
        echo " "
        echo -e "======= $(colorize "SIM SLOT MENU" white) ======="
        
        local slot_response=$(atcli_smd8 AT^SWITCH_SLOT? | tr -d '\r')
        local current_sim_slot
        local slot_number

        if echo "$slot_response" | grep -q "SIM1 ENABLE"; then
            current_sim_slot="SIM SLOT 1"
            slot_number=1
        elif echo "$slot_response" | grep -q "SIM2 ENABLE"; then
            current_sim_slot="SIM SLOT 2"
            slot_number=2
        elif echo "$slot_response" | grep -q "ERROR"; then
            current_sim_slot="$(colorize "ERROR" red) - Unable to read SIM slot status"
            slot_number=0
        else
            current_sim_slot="Unknown"
            slot_number=0
        fi
        
        local imsi_response=$(atcli_smd8 AT+CIMI | tr -d '\r')
        local current_imsi
        if echo "$imsi_response" | grep -q "ERROR"; then
            current_imsi="$(colorize "No SIM detected or unable to read IMSI" red)"
        else
            current_imsi=$(echo "$imsi_response" | grep -v "AT+CIMI" | grep -v "OK" | tr -d '\n\r ')
            current_imsi="$(colorize "$current_imsi" white)"
        fi

        echo -e "Current SIM Slot active: $(colorize "$current_sim_slot" green)"
        echo -e "Current SIM IMSI: $current_imsi"
        echo " "

        echo "Available SIM slots:"
        if [ "$slot_number" -eq 1 ]; then
            echo -e "1) Switch to SIM SLOT 1 ($(colorize "ACTIVE" green))"
        else
            echo "1) Switch to SIM SLOT 1"
        fi
        if [ "$slot_number" -eq 2 ]; then
            echo -e "2) Switch to SIM SLOT 2 ($(colorize "ACTIVE" green))"
        else
            echo "2) Switch to SIM SLOT 2"
        fi
        echo "B) Back to main menu"
        echo " "
        
        read -p "Enter your choice: " choice

        case "$choice" in
            1)
                at_command "AT^SWITCH_SLOT=0" \
                    "SIM Slot successfully set to: $(colorize "SIM SLOT 1" green)" \
                    "$(colorize "ERROR" red): Failed to change SIM card slot."
                echo " "
                echo -e "$(colorize "WARNING" yellow): To read new SIM you need to powercycle baseband"
                read -p "Do you want to restart the baseband now? (y/n): " restart_choice
                if [[ "$restart_choice" =~ ^[Yy]$ ]]; then
                    echo "Restarting baseband..."
                    at_command "AT+CFUN=0" "Radio OFF" "Failed to turn radio OFF"
                    sleep 2
                    at_command "AT+CFUN=1" "Radio ON, baseband restarted!" "Failed to turn radio ON"
                    echo -e "$(colorize "Baseband restarted successfully" green)"
                    sleep 2
                fi
                ;;
            2)
                at_command "AT^SWITCH_SLOT=1" \
                    "SIM Slot successfully set to: $(colorize "SIM SLOT 2" green)" \
                    "$(colorize "ERROR" red): Failed to change SIM card slot."
                echo " "
                echo -e "$(colorize "WARNING" yellow): To read new SIM you need to powercycle baseband"
                read -p "Do you want to restart the baseband now? (y/n): " restart_choice
                if [[ "$restart_choice" =~ ^[Yy]$ ]]; then
                    echo "Restarting baseband..."
                    at_command "AT+CFUN=0" "Radio OFF" "Failed to turn radio OFF"
                    sleep 2
                    at_command "AT+CFUN=1" "Radio ON, baseband restarted!" "Failed to turn radio ON"
                    echo -e "$(colorize "Baseband restarted successfully" green)"
                    sleep 2
                fi
                ;;
            B|b)
                break
                ;;
            *)
                echo "Invalid choice. Please try again."
                ;;
        esac
    done
}

# Function to parse AT^DEBUG?
parse_debug() {
    local band="" bw="" rsrp="" rsrq="" rssi="" snr="" pci="" channel=""
    local debug_info
    local -a table_rows=()
    
    debug_info=$(atcli "AT^DEBUG?")
    
    add_row() {
        if [[ -n "$band" ]]; then
            local band_col="$band"
            local pci_earfcn="${pci:-?}/${channel:-?}"
            local bw_col="${bw:--}"
            local rsrp_plain="${rsrp:--}"
            local rsrq_plain="${rsrq:--}"
            local rssi_plain="${rssi:--}"
            local snr_plain="${snr:--}"
            
            local rsrp_col="$rsrp_plain"
            local rsrq_col="$rsrq_plain"
            local rssi_col="$rssi_plain"
            local snr_col="$snr_plain"
            
            [[ -n "$rsrp" ]] && rsrp_col="$(colorize "$rsrp" rsrp)"
            [[ -n "$rsrq" ]] && rsrq_col="$(colorize "$rsrq" rsrq)"
            [[ -n "$rssi" ]] && rssi_col="$(colorize "$rssi" rssi)"
            [[ -n "$snr" ]] && snr_col="$(colorize "$snr" snr)"
            
            table_rows+=("$band_col|$pci_earfcn|$bw_col|$rsrp_col|$rsrp_plain|$rsrq_col|$rsrq_plain|$rssi_col|$rssi_plain|$snr_col|$snr_plain")
        fi
    }
    
    while IFS= read -r line; do
        # WCDMA (3G) bands
        if [[ "$line" =~ ^RAT:WCDMA ]]; then
            add_row
            is_wcdma=1
            band=""
            bw="" rsrp="" rsrq="" rssi="" snr="" pci="" channel=""
            rscp="" ecio="" psc=""
        fi
        
        # Reset if it's in LTE\NR mode
        if [[ "$line" =~ ^(pcell|scell):.*lte_band:([0-9]+) ]] || [[ "$line" =~ ^nr_band: ]]; then
            is_wcdma=0
        fi
        
        # WCDMA (3G) data extraction
        if [[ $is_wcdma -eq 1 ]]; then
            if [[ "$line" =~ ^band:([0-9]+) ]] && [[ -z "$band" ]]; then
                band="WCDMA B${BASH_REMATCH[1]}"
            fi
            [[ "$line" =~ ^band_width:([0-9.]+)MHz ]] && bw="${BASH_REMATCH[1]}"
            [[ "$line" =~ ^channel:([0-9]+) ]] && channel="${BASH_REMATCH[1]}"
            [[ "$line" =~ psc:([0-9]+) ]] && psc="${BASH_REMATCH[1]}"
            [[ "$line" =~ rscp:(-?[0-9.]+)dBm ]] && rscp="${BASH_REMATCH[1]}"
            [[ "$line" =~ ecio:(-?[0-9.]+)dB ]] && ecio="${BASH_REMATCH[1]}"
            if [[ "$line" =~ ^rssi:(-?[0-9.]+)dBm ]]; then
                rssi="${BASH_REMATCH[1]}"
            fi
        fi

        # LTE bands
        if [[ "$line" =~ ^(pcell|scell):.*lte_band:([0-9]+) ]]; then
            add_row
            band="LTE B${BASH_REMATCH[2]}"
            bw="" rsrp="" rsrq="" rssi="" snr="" pci="" channel=""
            [[ "$line" =~ lte_band_width:([0-9.]+) ]] && bw="${BASH_REMATCH[1]}"
        fi
        
        # NR band
        if [[ "$line" =~ ^nr_band:(n[0-9]+) ]]; then
            add_row
            band="NR $(echo "${BASH_REMATCH[1]}" | tr '[:lower:]' '[:upper:]')"
            bw="" rsrp="" rsrq="" rssi="" snr="" pci="" channel=""
        fi
        
        # Extract data
        [[ "$line" =~ channel:([0-9]+) ]] && channel="${BASH_REMATCH[1]}"
        [[ "$line" =~ pci:([0-9]+) ]] && pci="${BASH_REMATCH[1]}"
        [[ "$line" =~ (lte_rsrp|nr_rsrp):(-?[0-9.]+)dBm ]] && rsrp="${BASH_REMATCH[2]}"
        [[ "$line" =~ rsrq:(-?[0-9.]+)dB ]] && rsrq="${BASH_REMATCH[1]}"
        [[ "$line" =~ lte_rssi:(-?[0-9.]+)dBm ]] && rssi="${BASH_REMATCH[1]}"
        [[ "$line" =~ (lte_snr|nr_snr):(-?[0-9.]+)dB ]] && snr="${BASH_REMATCH[2]}"
        [[ "$line" =~ nr_band_width:([0-9.]+) ]] && bw="${BASH_REMATCH[1]}"
        [[ "$line" =~ nr_channel:([0-9]+) ]] && channel="${BASH_REMATCH[1]}"
        [[ "$line" =~ nr_pci:([0-9]+) ]] && pci="${BASH_REMATCH[1]}"
    done <<< "$debug_info"
    
    add_row
    
    if [[ ${#table_rows[@]} -gt 0 ]]; then
        printf "  %-10s | %-15s | %-9s | %-12s | %-11s | %-13s | %-10s\n" \
            "Band" "PCI/EARFCN" "BW (MHz)" "RSRP (dBm)" "RSRQ (dB)" "RSSI (dBm)" "SNR (dB)"
        printf "  %s\n" "$(printf '%.0s-' {1..105})"
        
        for row in "${table_rows[@]}"; do
            IFS='|' read -r band pci_earfcn bw rsrp_col rsrp_plain rsrq_col rsrq_plain rssi_col rssi_plain snr_col snr_plain <<< "$row"
            
            # Padding
            local rsrp_pad=$((12 - ${#rsrp_plain}))
            local rsrq_pad=$((11 - ${#rsrq_plain}))
            local rssi_pad=$((13 - ${#rssi_plain}))
            local snr_pad=$((10 - ${#snr_plain}))
            
            printf "  %-10s | %-15s | %-9s | %s%-*s | %s%-*s | %s%-*s | %s\n" \
                "$band" "$pci_earfcn" "$bw" \
                "$rsrp_col" "$rsrp_pad" "" \
                "$rsrq_col" "$rsrq_pad" "" \
                "$rssi_col" "$rssi_pad" "" \
                "$snr_col"
        done

        printf "  %s\n" "$(printf '%.0s-' {1..105})"
    fi
}

show_pdp_contexts() {
    atcli "AT+CGPIAF=1,1,1,1" > /dev/null
    local_pdp_output=$(atcli "AT+CGCONTRDP" 2>/dev/null | grep '+CGCONTRDP:')
    
    if [ -n "$local_pdp_output" ]; then
        echo "PDP Contexts: "
        
        first_line=1
        while IFS= read -r line; do
            if [[ "$line" =~ ^\+CGCONTRDP: ]]; then
                printf "%s" "$out"
                out=$'\n'
                local data="${line#*: }"
                IFS=',' read -ra fields <<< "$data"
                
                local cid="${fields[0]}"
                local bearer_id="${fields[1]}"
                local apn=$(echo "${fields[2]}" | tr -d ' ')
                
                echo -e "  Context ID: $(colorize "$cid" white) (Bearer: $(colorize "$bearer_id" white))"
                [ -n "$apn" ] && echo -e "  APN: $(colorize "$apn" white)"
                
                local all_ips=($(echo "$line" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'))
                local all_ipv6=($(echo "$line" | grep -oE '([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}'))
                
                local ipv4="${all_ips[0]:-}"
                local dns1v4="${all_ips[1]:-}"
                local dns2v4="${all_ips[2]:-}"
                
                local ipv6="${all_ipv6[0]:-}"
                local gw6="${all_ipv6[1]:-}"
                local dns1v6="${all_ipv6[2]:-}"
                local dns2v6="${all_ipv6[3]:-}"
                
                [ -n "$ipv4" ] && echo -e "  IPv4: $(colorize "$ipv4" white)"
                [ -n "$ipv6" ] && echo -e "  IPv6: $(colorize "$ipv6" white)"
                [ -n "$gw6" ] && echo -e "  Gateway v6: $(colorize "$gw6" white)"
                [ -n "$dns1v4" ] && echo -e "  DNS1 (v4): $(colorize "$dns1v4" white)"
                [ -n "$dns2v4" ] && echo -e "  DNS2 (v4): $(colorize "$dns2v4" white)"
                [ -n "$dns1v6" ] && echo -e "  DNS1 (v6): $(colorize "$dns1v6" white)"
                [ -n "$dns2v6" ] && echo -e "  DNS2 (v6): $(colorize "$dns2v6" white)"
            fi
        done <<< "$local_pdp_output"
    else
        echo "  No PDP active"
    fi
    echo " "
}

# Function to display modem and system info
show_info_header() {
    local hide_sensitive=${1:-0}

    echo "========================================"
    echo -e "            $(colorize "MODEM STATUS" white)               "
    echo "========================================"

    # System uptime
    local uptime_info=$(awk '{d=int($1/86400); h=int(($1%86400)/3600); m=int(($1%3600)/60); printf "%d days, %d hours, %d minutes\n", d, h, m}' /proc/uptime)
    echo " "
    echo -e "System Uptime: $(colorize "$uptime_info" white)"
    echo " "

    # Get ATI info
    local ati_output=$(atcli "ATI" 2>/dev/null)
    local temp_output=$(atcli "AT^TEMP?" 2>/dev/null)
    local hw_version=$(atcli "AT+SKUID" 2>/dev/null)
    local sw_version=$(atcli "AT^VERSION?" 2>/dev/null)
    if [ $? -eq 0 ]; then
        local manufacturer=$(echo "$ati_output" | grep "Manufacturer:" | cut -d':' -f2 | xargs)
        local model=$(echo "$ati_output" | grep "Model:" | cut -d':' -f2 | xargs)
        local imei=$(echo "$ati_output" | grep "IMEI:" | cut -d':' -f2 | xargs)
        local hw_ver=$(echo "$hw_version" | grep "HW Revision:" | cut -d':' -f2 | awk '{print $1}' | xargs)
        local sw_ver=$(echo "$sw_version" | grep "VERSION:" | cut -d':' -f2 | awk '{print $1}' | xargs)
        local pa_temp=$(echo "$temp_output" | grep "PA:" | cut -d':' -f2 | xargs)
        local skin_temp=$(echo "$temp_output" | grep "Skin Sensor:" | cut -d':' -f2 | xargs)
        local tsens_temp=$(echo "$temp_output" | grep "TSENS:" | cut -d':' -f2 | xargs)

        echo "Modem Info:"
        echo -e "  Manufacturer: $(colorize "$manufacturer" white)"
        echo -e "  Model: $(colorize "$model" white)"
        if [ "$hide_sensitive" -eq 0 ]; then
            echo -e "  IMEI: $(colorize "$imei" white)"
        fi
        echo -e "  HW Version: $(colorize "$hw_ver" white)"
        echo -e "  SW Version: $(colorize "$sw_ver" white)"
            
        echo "  PA Temp: $(colorize $pa_temp temp)"
        echo "  SKIN Temp: $(colorize $skin_temp temp)"
        echo "  TSENS Temp: $(colorize $tsens_temp temp)"
        echo " "
    fi

    # Get device mode
    radio_current_mode=$(atcli "AT^SLMODE?" | grep '\^SLMODE:' | cut -d "," -f 2 | tr -d '\r')
        case "$radio_current_mode" in
        1) radio_mode="3G only" ;;
        2) radio_mode="4G only" ;;
        3) radio_mode="3G+4G" ;;
        4) radio_mode="5G only" ;;
        5) radio_mode="3G+5G" ;;
        6) radio_mode="4G+5G" ;;
        7) radio_mode="3G+4G+5G" ;;
        *) radio_mode="Unknown" ;;
    esac

    echo -e "Device Mode: $(colorize "$radio_mode" green)"

    # Get current SIM slot status & IMSI
    local slot_response=$(atcli AT^SWITCH_SLOT? | tr -d '\r')
    local current_sim_slot

    if echo "$slot_response" | grep -q "SIM1 ENABLE"; then
        current_sim_slot="SIM SLOT 1"        
    elif echo "$slot_response" | grep -q "SIM2 ENABLE"; then
        current_sim_slot="SIM SLOT 2"
    elif echo "$slot_response" | grep -q "ERROR"; then
        current_sim_slot="$(colorize "ERROR" red) - Unable to read SIM slot status"
    else
        current_sim_slot="Unknown"
    fi

    # Get current IMSI
    local current_imsi=$(atcli AT+CIMI | grep -v AT+CIMI | grep -v OK | tr -d '\r\n')
    
    echo " "
    echo "SIM Status:"
    echo -e "  Active SIM Slot: $(colorize "$current_sim_slot" white)"
    
    # Print IMSI only if it's not ERROR
    if ! echo "$current_imsi" | grep -q "ERROR"; then
        if [ "$hide_sensitive" -eq 0 ]; then
            echo -e "  Active SIM IMSI: $(colorize "$current_imsi" white)"
        fi
    fi

    # Get registration status
    local creg_output=$(atcli "AT+CREG?" 2>/dev/null)
    local reg_status=""
    local show_network_info=false

    if [ $? -eq 0 ]; then
	local creg_code=$(echo "$creg_output" | grep "+CREG:" | awk -F',' '{print $2}' | tr -d ' \r\n')
        case $creg_code in
            1)
                reg_status="$(colorize "Yes" green) ($(colorize "Home" white))"
                show_network_info=true
                ;;
            3)
                reg_status="$(colorize "No" red) ($(colorize "Denied" red))"
                ;;
            5)
                reg_status="$(colorize "Yes" green) ($(colorize "Roaming" yellow))"
                show_network_info=true
                ;;
            *)
                reg_status="$(colorize "Unknown" white)"
                ;;
        esac
        echo " "
        echo "Network Status:"
        echo -e "  Registered: $reg_status"
    fi

    # Show operator and signal only if registered (status 1 or 5)
    if [ "$show_network_info" = true ]; then
        # Get operator name
        local cops_output=$(atcli "AT+COPS?" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local operator=$(echo "$cops_output" | awk -F'"' '
                /\+COPS:/ {
                first_word = $2
                sub(/\r/,"",first_word)
                sub(/^[ \t]+/,"",first_word)
                sub(/[ \t].*$/,"",first_word)
                if (first_word != "" && !seen[first_word]++) print first_word
                }')
            if [ -n "$operator" ]; then
                echo -e "  Operator: $(colorize "$operator" white)"
            fi
        fi

        # Get signal strength
        local csq_output=$(atcli "AT+CSQ" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local csq=$(echo "$csq_output" | grep -o "+CSQ: [0-9]\{1,2\}" | grep -o "[0-9]\{1,2\}")
            if [ -n "$csq" ] && [ "$csq" -ne 99 ]; then
                local csq_per=$(( csq * 100 / 31 ))
                local csq_rssi=$(( 2 * csq - 113 ))
                echo "  Signal: $(colorize $csq_per percent) ($(colorize $csq_rssi rssi) dBm)"
                echo "  CA Status:"
                
                echo "  ---------------------------------------------------------------------------------------------------------"
                parse_debug
            else
                echo "  Signal: No signal"
            fi
        fi

        # Show IPv4/IPv6 PDP Status connection
        echo " "
        show_pdp_contexts
    fi
    echo " "
}

# Function to display bands
show_enabled_disabled_bands() {
    echo " "
    atcli_smd8 "AT^BAND_PREF_EXT?" | grep -E "Enable|Disable" | while IFS= read -r line; 
    do
        if [[ $line =~ WCDMA,Enable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
            echo -e "WCDMA Enabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ WCDMA,Disable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
            [[ -n "$bands" ]] && echo -e "WCDMA Disabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ LTE,Enable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
            echo -e "LTE Enabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ LTE,Disable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
            [[ -n "$bands" ]] && echo -e "LTE Disabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ NR5G_NSA,Enable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
            echo -e "5G NSA Enabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ NR5G_NSA,Disable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
            [[ -n "$bands" ]] && echo -e "5G NSA Disabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ NR5G_SA,Enable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands ://' | xargs | sed 's/,$//')
            echo -e "5G SA Enabled Bands: $(colorize "$bands" white)"
        elif [[ $line =~ NR5G_SA,Disable ]]; then
            bands=$(echo "$line" | sed 's/.*Bands://' | xargs | sed 's/,$//')
            [[ -n "$bands" ]] && echo -e "5G SA Disabled Bands: $(colorize "$bands" white)"
        fi
    done
} 

# Function to reboot system
reboot_system() {
    echo " "
    echo -e "======= ${WHITE_BOND}REBOOT SYSTEM${RESET} ======="
    echo -e "$(colorize "WARNING" yellow)"": The system will reboot now!"
    read -p "Are you sure you want to reboot? (y/n): " confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        echo "Rebooting system..."
        reboot
    else
        echo "Reboot cancelled"
    fi
}

live_mode() {
    local hide_sensitive=${1:-0}
    echo -ne "$HIDE_CURSOR"
    trap "echo -ne '$SHOW_CURSOR'; exit" INT TERM EXIT
    clear

    show_info_header "$hide_sensitive"

    while true; do
        sleep 3 
        update_dynamic_info  "$hide_sensitive"
    done
}

# Main menu
case $1 in
    "")  
        while true; do
            echo ""
            echo "========================================"
            echo -e "          $(colorize "CONFIGURATION MENU" white)"
            echo "========================================"
            echo " 1) Show Current MobileAP Configuration"
            echo " 2) Set APN"
            echo " 3) Set Radio Device Mode"
            echo " 4) Band Lock"
            echo " 5) Cell Lock"
            echo " 6) Enable/Disable Airplane Mode"
            echo " 7) Enable/Disable Autoconnect"
            echo " 8) Enable/Disable Roaming"
            echo " 9) Enable/Disable Bridge Mode"
            echo "10) Change SIM Slot"
            echo "11) Change IP Address"
            echo "12) Reboot System"
            echo "13) Show Modem Information"
            echo "14) Show Modem Information - Live Mode"
            echo "15) Show Modem Information - Live Mode - Hidden Sensitive"
            echo "16) Change Password"
            echo "17) Send Custom AT Command"
            echo " Q) Exit"
            echo "========================================"
            read -p "Select an option: " choice

            case $choice in
                1) show_mobileap_config ;;
                2) apn_menu ;;
                3) device_mode_menu ;;
                4) band_lock_menu ;;
                5) cell_lock_menu ;;
                6) toggle_airplane_mode ;;
                7) toggle_autoconnect ;;
                8) toggle_roaming ;;
                9) toggle_bridge ;;
                10) simslot_menu ;;
                11) change_ip ;;
                12) reboot_system ;;
                13) show_info_header ;;
                14) live_mode 0 ;;
                15) live_mode 1 ;;
                16) passwd operator ;;
                17) at_menu ;;
                Q|q) echo "Bye!"; exit 0 ;;
                *) echo "Invalid option!" ;;
            esac
        done
        ;;
    live)
        live_mode 0 ;;
    live-hidden)
        live_mode 1 ;;        
    *)
        echo "Invalid option!" ;;
esac
